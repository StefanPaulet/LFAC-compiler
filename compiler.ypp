%{
    #include <fstream>
    #include <iostream>
    #include "main.hpp"

    extern "C" {
        int yylex ( void );
    }  

    #include "../utilities/Scope/Scope.hpp"
    #include "../utilities/Scope/impl/Scope.hpp"

    Scope * pCurrentScope = Scope :: pGlobalScope;
    Scope * pNonClassScope;
    std :: ofstream debugOut ( "debug.out" );

    unsigned long long int errorCount = 0;

    using StringList               = std :: list < char const * >;
    using ArraytypePair            = TypeEntry :: ArraytypePair;
    using ParameterDeclarationPair = Scope :: ParameterDeclarationPair;
    using ParameterDeclarationList = Scope :: ParameterDeclarationList;
    using IdentifierAccessPair     = std :: pair < char const *, SymbolEntry * >;
    using IdentifierList           = std :: list < SymbolEntry * >;
    using IdentifierLookup         = std :: pair < bool, SymbolEntry * >;
%}

%union {
    int intValue;
    float floatValue;
    char charValue;
    char boolValue;
    char const * stringValue;
    
#ifdef __cplusplus
    Scope * pScope;
    ParameterDeclarationList * pParamDeclarationList;
    StringList * pStringList;
    ArraytypePair * pArraytypePair;
    IdentifierLookup * pIdentifierLookup;
    IdentifierList * pSymbolList;
#endif
}
    

%token <intValue>      T_INT_NUMBER
%token <charValue>     T_CHAR_VALUE
%token <floatValue>    T_FLOAT_NUMBER
%token <boolValue>     T_BOOL_VALUE
%token <stringValue>   T_STRING_VALUE

%token T_MAIN_IDENTIFIER
%token T_CLASS
%token T_IF
%token T_WHILE
%token T_FOR
%token T_CONST

%token <stringValue> T_TYPE
%token <stringValue> T_IDENTIFIER

%nterm <stringValue> N_MIXED_TYPE

%nterm <intValue> N_CONSTANT_VALUE

%nterm <pIdentifierLookup> N_SYMBOL_ACCESS
%nterm <pIdentifierLookup> N_NON_ARRAY_SYMBOL_ACCESS
%nterm <pIdentifierLookup> N_ARRAY_SYMBOL_ACCESS

%nterm <pIdentifierLookup> N_VARIABLE_ACCESS

%nterm <pScope> M_CLASS_ACCESS_SCOPE_CHANGE
%nterm <pScope> M_PARAMETER_LOOKUP_SCOPE_CHANGE

%nterm <pSymbolList> N_PARAMETER
%nterm <pSymbolList> N_PARAMETER_LIST

%nterm <intValue> N_EXPRESSION

%nterm <boolValue> N_BOOL_EXPRESSION

%nterm <pScope> N_DECLARATION
%nterm <pScope> N_BLOCK_SCOPE_DECLARATION
%nterm <pScope> N_VARIABLE_DECLARATION
%nterm <pScope> N_VARIABLE_DEFINITION
%nterm <pScope> N_DECLARATION_LIST

%nterm <pArraytypePair> N_ARRAY_SUBSCRIPT

%nterm <pScope> N_CLASS_DECLARATION
%nterm <stringValue> M_BLOCK_BEGIN

%nterm <pScope> N_FUNCTION_DECLARATION
%nterm <pParamDeclarationList> N_PARAMETER_DECLARATION
%nterm <pParamDeclarationList> N_PARAMETER_DECLARATION_LIST

%nterm <pScope> N_BLOCK
%nterm <stringValue> N_STATEMENT

%nterm <stringValue> N_ASSIGNMENT
%nterm <stringValue> N_IF_STATEMENT
%nterm <stringValue> N_WHILE_STATEMENT
%nterm <stringValue> N_FOR_STATEMENT

%left T_BAND
%left T_BOR
%right UNOT


%left '-' '+'
%left '*' '/' 
%right UMINUS


%start N_START

%%

N_START:
    N_DECLARATION
    T_TYPE T_MAIN_IDENTIFIER '(' ')' N_BLOCK {
        debugOut << "Scope: " << pCurrentScope << '\n' << "With variables:\n";
        for ( auto e : * pCurrentScope->getSymbolTable()->getSymbols() ) {
            debugOut << e->getTypeName() << ' ' << e->getName() << '\n';
        }
        debugOut << "And types:\n";
        for ( auto e : * pCurrentScope->getTypeTable()->getTypes() ) {
            debugOut << e->getName() << ' ' << e->getLength() << '\n';
        }
        debugOut << '\n';
        
        std :: cout << "Error count: " << errorCount << '\n';
    }

N_CONSTANT_VALUE:
    T_INT_NUMBER |
    T_FLOAT_NUMBER { } |
    T_CHAR_VALUE { } |
    T_BOOL_VALUE { } |
    T_STRING_VALUE { }

N_SYMBOL_ACCESS:
    N_NON_ARRAY_SYMBOL_ACCESS |
    N_ARRAY_SYMBOL_ACCESS

N_NON_ARRAY_SYMBOL_ACCESS:
    N_SYMBOL_ACCESS M_PARAMETER_LOOKUP_SCOPE_CHANGE '(' N_PARAMETER ')' {

        if ( pCurrentScope != nullptr ) {
            if ( ! $1->first && $1->second->getType() != nullptr ) {
                auto pFunction = dynamic_cast < FunctionEntry * > ( $1->second );
                if ( pFunction == nullptr ) {
                    $1->first = true;
                    error :: nonFunctionCallError ( $1->second->getName() );
                } else {
                    if ( pFunction->matchParameterList ( $4 ) ) {
                        $1->second = pFunction->getScope()->getSymbolTable()->lookUpSymbol ( "$return" );
                    } else {
                        $1->first = true;
                    }
                }
            }
        }
        $$ = $1;
        pCurrentScope = $2;
    } |
    T_IDENTIFIER {

        if ( pCurrentScope != nullptr ) {
            auto pSymbol = pCurrentScope->getSymbol ( $1 );
            if ( pSymbol == nullptr ) {
                $$ = new IdentifierLookup ( false, new VariableEntry ( $1, nullptr ) );
            } else {
                $$ = new IdentifierLookup ( false, pSymbol );
            }
        } else {
            $$ = new IdentifierLookup ( false, new VariableEntry ( $1, nullptr ) );
        }
    }

M_PARAMETER_LOOKUP_SCOPE_CHANGE:
    { $$ = pCurrentScope; pCurrentScope = pNonClassScope; }

N_ARRAY_SYMBOL_ACCESS:
    N_NON_ARRAY_SYMBOL_ACCESS N_ARRAY_SUBSCRIPT {

        if ( ! $1->first ) {
            auto pType = $1->second->getType();
            if ( pType != nullptr ) {
                if ( pType->getName()[0] != 'A' ) {
                    $1->first = true;
                    error :: nonArrayTypeArrayAccess ( $1->second->getName() );
                } else {
                    if ( pType->matchArraySubscript ( $2 ) ) {
                        $1->second = ( reinterpret_cast < VariableEntry * > ( $1->second ) )->getValue().arrayValue[ $2->second ];
                    } else {
                        $1->first = true;
                    }
                }
            }
        }
        $$ = $1;
    }

N_VARIABLE_ACCESS:
    N_VARIABLE_ACCESS M_CLASS_ACCESS_SCOPE_CHANGE {
        if ( ! $1->first ) {
            std :: string typeName = $1->second->getTypeName();
            if ( typeName[0] < '0' || typeName[0] > '9' ) {
                error :: nonStructureType ( typeName.c_str() );
                $1->first = true;
                pCurrentScope = nullptr;
            } else {
                pCurrentScope = ( reinterpret_cast < StructuredTypeEntry * > ( $1->second->getType() ) )->getScope();
            }
        } else {
            pCurrentScope = nullptr;
        }
        delete $1;
    } '.' N_SYMBOL_ACCESS { 
        if ( pCurrentScope != nullptr ) {
            if ( $5->second == nullptr ) {
                $5->first = true;
                error :: nonExistentMember ( $1->second->getTypeName().c_str(), $5->second->getName() );
            }
        } 
        pCurrentScope = $2;
        $$ = $5;
    } |
    N_SYMBOL_ACCESS {
        if ( ! $1->first ) {
            if ( $1->second->getType() == nullptr ) {
                $1->first = true;
                error :: undeclaredSymbol ( $1->second->getName() );
            }
        }
        $$ = $1;
    }

M_CLASS_ACCESS_SCOPE_CHANGE:
    { $$ = pCurrentScope; }

N_PARAMETER:
    N_PARAMETER_LIST {
        $$ = $1;
    }|
    { $$ = new IdentifierList; };

N_PARAMETER_LIST:
    N_PARAMETER_LIST ',' N_SYMBOL_ACCESS {
        $1->push_back ( $3->second );
        $$ = $1;
    } |
    N_SYMBOL_ACCESS {
        $$ = new IdentifierList;
        $$->push_back ( $1->second );
    }

    
N_MIXED_TYPE:
    T_TYPE |
    T_IDENTIFIER;

N_EXPRESSION: 
    N_EXPRESSION '+' N_EXPRESSION |
    N_EXPRESSION '-' N_EXPRESSION |
    N_EXPRESSION '*' N_EXPRESSION |
    N_EXPRESSION '/' N_EXPRESSION |
    '(' N_EXPRESSION ')' {} |
    '-' N_EXPRESSION %prec UMINUS {} |
    N_CONSTANT_VALUE |
    N_VARIABLE_ACCESS { }


N_BOOL_EXPRESSION:
    N_BOOL_EXPRESSION T_BAND N_BOOL_EXPRESSION |
    N_BOOL_EXPRESSION T_BOR N_BOOL_EXPRESSION |
    '!' N_BOOL_EXPRESSION %prec UNOT { }| 
    N_CONSTANT_VALUE { } |
    N_VARIABLE_ACCESS { }
    

N_DECLARATION:
    N_DECLARATION N_FUNCTION_DECLARATION ';' |
    N_DECLARATION  N_BLOCK_SCOPE_DECLARATION ';' |
    N_DECLARATION error ';' { ++ errorCount; } |
    { };


N_BLOCK_SCOPE_DECLARATION:
    N_CLASS_DECLARATION |
    N_VARIABLE_DECLARATION


N_VARIABLE_DECLARATION:
    N_MIXED_TYPE T_IDENTIFIER {
        pCurrentScope->addVariable ( $1, $2 );
    } |
    N_MIXED_TYPE T_CONST T_IDENTIFIER {
        error :: unitializedConstIdentifier();
    } |
    N_MIXED_TYPE T_IDENTIFIER N_ARRAY_SUBSCRIPT {
        pCurrentScope->addArrayVariable ( $1, $2, $3->first, $3->second );
    } |
    N_MIXED_TYPE T_CONST T_IDENTIFIER N_ARRAY_SUBSCRIPT {
        error :: unitializedConstIdentifier();
    }

N_DECLARATION_LIST:
    N_DECLARATION_LIST ',' T_IDENTIFIER |
    T_IDENTIFIER

N_ARRAY_SUBSCRIPT:
    '[' T_INT_NUMBER ']' N_ARRAY_SUBSCRIPT {
        char * pAux = new char;
        sprintf ( pAux, "A%d_", $2 );
        strcat ( pAux, $4->first );
        $$ = new ArraytypePair;
        $$->first = pAux;
        $$->second = $4->second * $2;
    } |
    '[' T_INT_NUMBER ']' { 
        $$ = new ArraytypePair;
        $$->first = new char;
        sprintf ( $$->first, "A%d_", $2 );
        $$->second = $2;
    };


N_CLASS_DECLARATION:
    T_CLASS T_IDENTIFIER '{' 
    M_BLOCK_BEGIN
    N_DECLARATION
    '}' {
        auto classScope = pCurrentScope;
        pCurrentScope = pCurrentScope->getUpperScope();
        auto pNewEntry = pCurrentScope->addUserDefinedType ( $2, classScope );
        if ( pNewEntry != nullptr ) {
            pCurrentScope->setUserDefinedTypeLength ( pNewEntry );
        }
    } 


M_BLOCK_BEGIN: { 
        auto newScope = new Scope ( pCurrentScope );
        pCurrentScope = pNonClassScope = newScope; 
    }


N_FUNCTION_DECLARATION: 
    N_MIXED_TYPE T_IDENTIFIER '(' N_PARAMETER_DECLARATION ')' N_BLOCK {
        pCurrentScope->addFunction ( $2, $1, nullptr, $4, $6 );
        $6->addVariable ( $1, "$return" );
    } |
    N_MIXED_TYPE T_IDENTIFIER '(' N_PARAMETER_DECLARATION ')' {
        error :: functionDeclaration();
    }

N_PARAMETER_DECLARATION:
    N_PARAMETER_DECLARATION_LIST |
    { $$ = new ParameterDeclarationList; };


N_PARAMETER_DECLARATION_LIST:
    N_PARAMETER_DECLARATION_LIST ',' N_MIXED_TYPE T_IDENTIFIER {
        $1->push_back ( new ParameterDeclarationPair { $3, $4 } );
        $$ = $1;
    } |
    N_MIXED_TYPE T_IDENTIFIER {
        $$ = new ParameterDeclarationList;
        $$->push_back( new ParameterDeclarationPair { $1, $2 } );
    }


N_BLOCK: '{' M_BLOCK_BEGIN N_STATEMENT '}' {
        $$ = pCurrentScope;
        debugOut << "Scope: " << pCurrentScope << '\n' << "With variables:\n";
        for ( auto e : * pCurrentScope->getSymbolTable()->getSymbols() ) {
            debugOut << e->getTypeName() << ' ' << e->getName() << '\n';
        }
        debugOut << "And types:\n";
        for ( auto e : * pCurrentScope->getTypeTable()->getTypes() ) {
            debugOut << e->getName() << ' ' << e->getLength() << '\n';
        }
        debugOut << '\n';
        pCurrentScope = pCurrentScope->getUpperScope();
    }


N_STATEMENT:
    N_STATEMENT N_ASSIGNMENT ';' |
    N_STATEMENT N_IF_STATEMENT |
    N_STATEMENT N_WHILE_STATEMENT |
    N_STATEMENT N_FOR_STATEMENT |
    N_STATEMENT N_EXPRESSION ';' |
    N_STATEMENT N_BLOCK_SCOPE_DECLARATION ';' { } |
    N_STATEMENT error ';' { ++ errorCount; }|
    N_STATEMENT N_BLOCK |
    { };


N_ASSIGNMENT:
    N_VARIABLE_ACCESS '=' N_EXPRESSION { } 


N_IF_STATEMENT:
    T_IF '(' N_BOOL_EXPRESSION ')' N_BLOCK { }


N_WHILE_STATEMENT:
    T_WHILE '(' N_BOOL_EXPRESSION ')' N_BLOCK { }


N_FOR_STATEMENT:
    T_FOR '(' ',' ',' ')' N_BLOCK { }

%%